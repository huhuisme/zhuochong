package com.hhhu;
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class PetFrame extends JFrame {

    private final List<BufferedImage> idleFrames = new ArrayList<>();
    private final List<BufferedImage> happyFrames = new ArrayList<>();
    private final List<BufferedImage> walkRightFrames = new ArrayList<>();
    private final List<BufferedImage> walkLeftFrames = new ArrayList<>();
    private final List<BufferedImage> restFrames = new ArrayList<>();
    private int currentFrame = 0;
    private Timer animationTimer;
    private Point dragOffset = new Point();
    private boolean isDragging = false;
    private boolean Happy = true;
    private boolean isHappy = false;//false idle true happy
    private boolean isWalk = false;
    private boolean isSleep = false;
    private Rectangle screenBounds;
    private Random r = new Random();
    private int moveSpeed = 3;

    public PetFrame() {
        setUndecorated(true);
        setBackground(new Color(0, 0, 0, 0));
        setAlwaysOnTop(true);
        setSize(100, 100);

        //获取屏幕边缘
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        screenBounds = new Rectangle();
        for (GraphicsDevice gd : ge.getScreenDevices()) {
            screenBounds = screenBounds.union(gd.getDefaultConfiguration().getBounds());
        }


        //加载图像资源
        loadPetImages();

        // 初始化动画定时器
        initAnimation();




        //鼠标监听器
        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                dragOffset = e.getPoint();
                isDragging = true;
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                isDragging = false;
            }

            @Override
            public void mouseClicked(MouseEvent e) {
                if(e.getClickCount() == 1){
                     Happy = true;
                     isHappy = !isHappy;
                    initAnimation();
                } else if(e.getClickCount() == 2){
                    Happy = false;
                    isWalk = !isWalk;
                    initAnimation();
                }
                if (e.getClickCount() == 3) {
                    System.exit(0);
                }
            }
        });

        addMouseMotionListener(new MouseAdapter() {
            @Override
            public void mouseDragged(MouseEvent e) {
                if (isDragging) {
                    Point newLocation = e.getLocationOnScreen();
                    setLocation(newLocation.x - dragOffset.x, newLocation.y - dragOffset.y);
                }
            }
        });
    }

    private void moveWindow() {
        //正在拖拽不自动移动
        if (isDragging) return;

        Point currentPos = getLocation();
        int newX = currentPos.x;

        // 边界检测和自动转向
        if (newX <= screenBounds.x) { // 碰到左边界
            isWalk = true;
            newX = screenBounds.x;
        }
        else if (newX + getWidth() >= screenBounds.x + screenBounds.width) { // 碰到右边界
            isWalk = false;
            newX = screenBounds.x + screenBounds.width - getWidth();
        }

        // 计算新位置
        if (isWalk) {
            newX += moveSpeed;
        } else {
            newX -= moveSpeed;
        }

        // 应用新位置
        setLocation(newX, currentPos.y);

    }


    private void loadPetImages() {
        try {
            //加载空闲状态动画帧
            for (int i = 1; i <= 2; i++) {
                BufferedImage frame = ImageIO.read(getClass().getResource("/images/idle/idle_" + i + ".png"));
                idleFrames.add(frame);
            }

            //加载开心状态动画帧
            for (int i = 1; i <= 10; i++) {
               BufferedImage frame = ImageIO.read(getClass().getResource("/images/happy/happy_" + i + ".png"));
//                BufferedImage frame = ImageIO.read(getClass().getResource("/images/walk_right/walk_right_" + i + ".png"));
                happyFrames.add(frame);
            }
            //加载向右行走动画帧
            for (int i = 1; i <= 5; i++) {
                BufferedImage frame = ImageIO.read(getClass().getResource("/images/walk_right/walk_right_" + i + ".png"));
                walkRightFrames.add(frame);
            }

            //加载向左行走动画帧
            for (int i = 1; i <= 5; i++) {
                BufferedImage frame = ImageIO.read(getClass().getResource("/images/walk_left/walk_left_" + i + ".png"));
                walkLeftFrames.add(frame);
            }
            for (int i = 1; i <= 3; i++) {
                BufferedImage frame = ImageIO.read(getClass().getResource("/images/sleep/sleep_" + i + ".png"));
                restFrames.add(frame);
            }
        } catch (Exception e) {
            e.printStackTrace();
            // 如果加载失败，创建占位图像
            createPlaceholderImages();
        }
    }

    // 初始化动画定时器
    private void initAnimation() {
        //停止现有定时器
        if (animationTimer != null && animationTimer.isRunning()) {
            animationTimer.stop();
        }

        //创建新定时器
        if (Happy) {
            if (isHappy) {
                animationTimer = new Timer(100, e -> { //Happy模式100ms/帧
                    List<BufferedImage> currentFrames = happyFrames;
                    currentFrame = (currentFrame + 1) % currentFrames.size();
                    repaint();
                });
            } else {
                animationTimer = new Timer(300, e -> { //sleep模式300ms/帧
                    List<BufferedImage> currentFrames = restFrames;
                    currentFrame = (currentFrame + 1) % currentFrames.size();
                    repaint();
                });
            }
        } else {
            animationTimer = new Timer(200, e -> { //Walk模式200ms/帧
                List<BufferedImage> currentFrames = isWalk ? walkRightFrames : walkLeftFrames;
                currentFrame = (currentFrame + 1) % currentFrames.size();
                moveWindow();
                repaint();
            });
        }
        animationTimer.start();


    }


    private void createPlaceholderImages() {
        //占位图像
        for (int i = 0; i < 4; i++) {
            BufferedImage img = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g2d = img.createGraphics();
            //绘制简单图形
            g2d.dispose();

            idleFrames.add(img);
        }
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        Graphics2D g2d = (Graphics2D) g;

        //启用抗锯齿
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        //绘制当前帧
        BufferedImage currentImage;
        if (Happy && isHappy && !happyFrames.isEmpty()) {
            currentImage = happyFrames.get(currentFrame % happyFrames.size());
        }else if(Happy && !isHappy && !idleFrames.isEmpty()){
            currentImage = restFrames.get(currentFrame % restFrames.size());
        }else if(!Happy && isWalk && !walkRightFrames.isEmpty()){
            currentImage = walkRightFrames.get(currentFrame % walkRightFrames.size());
        }else if(!Happy && !isWalk && !walkLeftFrames.isEmpty()){
            currentImage = walkLeftFrames.get(currentFrame % walkLeftFrames.size());
        }else{
            currentImage = idleFrames.get(currentFrame % idleFrames.size());
        }

        g2d.drawImage(currentImage, 0, 0, null);
    }
}